# Connect LLMs to E2B
E2B can work with any LLM and AI framework. The easiest way to connect an LLM to E2B is to use the tool use capabilities of the LLM (sometimes known as function calling).

If the LLM doesn't support tool use, you can, for example, prompt the LLM to output code snippets and then manually extract the code snippets with [RegEx](https://en.wikipedia.org/wiki/Regular_expression).

## Contents
- [OpenAI](#openai)
- [Anthropic](#anthropic)
- [Mistral](#mistral)
- [Groq](#groq)
- [Vercel AI SDK](#vercel-ai-sdk)
- [CrewAI](#crewai)
- [LangChain](#langchain)
- [LlamaIndex](#llamaindex)

---

## OpenAI
{/* You can use E2B with all the OpenAI's langauge models. */}

{/* ### o1 family
TODO */}

{/* ### GPT-4 family & GPT-3.5 family */}
<CodeGroup>
```python
# pip install openai e2b-code-interpreter
from openai import OpenAI
from e2b_code_interpreter import Sandbox

# Create OpenAI client
client = OpenAI()
prompt = "Calculate how many r's are in the word 'strawberry'"

# Define the tools
tools = [{
    "type": "function",
    "function": {
        "name": "execute_python",
        "description": "Execute python code in a Jupyter notebook cell and return result",
        "parameters": {
            "type": "object",
            "properties": {
                "code": {
                    "type": "string",
                    "description": "The python code to execute in a single cell"
                }
            },
            "required": ["code"]
        }
    }
}]

# Generate text with OpenAI
response = client.chat.completions.create(
    model="gpt-4o",
    messages=[{"role": "user", "content": prompt}],
    tools=tools,
)

# Execute the tool if it's called by the model
if response.choices[0].message.tool_calls:
    tool_call = response.choices[0].message.tool_calls[0]
    if tool_call.function.name == "execute_python":
        # Create a sandbox and execute the code
        with Sandbox() as sandbox:
            code = tool_call.function.arguments
            execution = sandbox.run_code(code)
            result = execution.text

        # Send the result back to the model
        response = client.chat.completions.create(
            model="gpt-4o",
            messages=[
                {"role": "user", "content": prompt},
                {"role": "function", "name": "execute_python", "content": result}
            ]
        )

print(response.choices[0].message.content)
```
</CodeGroup>

---

## Anthropic
<CodeGroup>
```python
# pip install anthropic e2b-code-interpreter
from anthropic import Anthropic
from e2b_code_interpreter import Sandbox

# Create Anthropic client
anthropic = Anthropic()
system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Send messages to Anthropic API
response = anthropic.messages.create(
    model="claude-3-5-sonnet-20240620",
    max_tokens=1024,
    messages=[
        {"role": "assistant", "content": system_prompt},
        {"role": "user", "content": prompt}
    ]
)

# Extract code from response
code = response.content[0].text

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.logs.stdout

print(result)
```
</CodeGroup>

---

## Mistral
<CodeGroup>
```python
# pip install mistralai e2b-code-interpreter
import os
from mistralai import Mistral
from e2b_code_interpreter import Sandbox

api_key = os.environ["MISTRAL_API_KEY"]

# Create Mistral client
client = Mistral(api_key=api_key)
system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Send the prompt to the model
response = client.chat.complete(
    model="codestral-latest",
    messages=[
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": prompt}
    ]
)

# Extract the code from the response
code = response.choices[0].message.content

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.text

print(result)
```
</CodeGroup>

---

## Groq
<CodeGroup>
```python
# pip install groq e2b-code-interpreter
import os
from groq import Groq
from e2b_code_interpreter import Sandbox

api_key = os.environ["GROQ_API_KEY"]

# Create Groq client
client = Groq(api_key=api_key)
system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry.'"

# Send the prompt to the model
response = client.chat.completions.create(
    model="llama3-70b-8192",
    messages=[
        {"role": "system", "content": system_prompt},
        {"role": "user", "content": prompt},
    ]
)

# Extract the code from the response
code = response.choices[0].message.content

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.text

print(result)
```
</CodeGroup>

---

## Vercel AI SDK
Vercel's [AI SDK](https://sdk.vercel.ai) offers support for multiple different LLM providers through a unified JavaScript interface that's easy to use.

<CodeGroup>
```js
// npm install ai @ai-sdk/openai zod @e2b/code-interpreter
import { openai } from '@ai-sdk/openai'
import { generateText } from 'ai'
import z from 'zod'
import { Sandbox } from '@e2b/code-interpreter'

// Create OpenAI client
const model = openai('gpt-4o')

const prompt = "Calculate how many r's are in the word 'strawberry'"

// Generate text with OpenAI
const { text } = await generateText({
  model,
  prompt,
  tools: {
    // Define a tool that runs code in a sandbox
    codeInterpreter: {
      description: 'Execute python code in a Jupyter notebook cell and return result',
      parameters: z.object({
        code: z.string().describe('The python code to execute in a single cell'),
      }),
      execute: async ({ code }) => {
        // Create a sandbox, execute LLM-generated code, and return the result
        const sandbox = await Sandbox.create()
        const { text, results, logs, error } = await sandbox.runCode(code)
        return results
      },
    },
  },
  // This is required to feed the tool call result back to the LLM
  maxSteps: 2
})

console.log(text)
```
</CodeGroup>

---

## CrewAI
[CrewAI](https://crewai.com/) is a platform for building AI agents.

<CodeGroup>
```python
# pip install crewai crewai[tools] e2b-code-interpreter
from crewai_tools import tool
from crewai import Agent, Task, Crew, LLM
from e2b_code_interpreter import Sandbox

@tool("Python interpreter tool")
def execute_python(code: str):
    """
    Execute Python code and return the results.
    """
    with Sandbox() as sandbox:
        execution = sandbox.run_code(code)
        return execution.text

# Define the agent
python_executor = Agent(
    role='Python Executor',
    goal='Execute Python code and return the results',
    backstory='You are an expert Python programmer capable of executing code and returning results.',
    tools=[execute_python],
    llm=LLM(model="gpt-4o")
)

# Define the task
execute_task = Task(
    description="Calculate how many r's are in the word 'strawberry'",
    agent=python_executor,
    expected_output="The number of r's in the word 'strawberry'"
)

# Create the crew
code_execution_crew = Crew(
    agents=[python_executor],
    tasks=[execute_task],
    verbose=True,
)

# Run the crew
result = code_execution_crew.kickoff()
print(result)
```
</CodeGroup>

---

## LangChain
[LangChain](https://langchain.com/) offers support for multiple different LLM providers.
<CodeGroup>
```python
# pip install langchain langchain-openai e2b-code-interpreter
from langchain_openai import ChatOpenAI
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import StrOutputParser
from e2b_code_interpreter import Sandbox

system_prompt = "You are a helpful assistant that can execute python code in a Jupyter notebook. Only respond with the code to be executed and nothing else. Strip backticks in code blocks."
prompt = "Calculate how many r's are in the word 'strawberry'"

# Create LangChain components
llm = ChatOpenAI(model="gpt-4o")
prompt_template = ChatPromptTemplate.from_messages([
    ("system", system_prompt),
    ("human", "{input}")
])

output_parser = StrOutputParser()

# Create the chain
chain = prompt_template | llm | output_parser

# Run the chain
code = chain.invoke({"input": prompt})

# Execute code in E2B Sandbox
with Sandbox() as sandbox:
    execution = sandbox.run_code(code)
    result = execution.text

print(result)
```
</CodeGroup>

---

## LlamaIndex
[LlamaIndex](https://www.llamaindex.ai/) offers support for multiple different LLM providers.
<CodeGroup>
```python
from llama_index.core.tools import FunctionTool
from llama_index.llms.openai import OpenAI
from llama_index.core.agent import ReActAgent
from e2b_code_interpreter import Sandbox

# Define the tool
def execute_python(code: str):
    with Sandbox() as sandbox:
        execution = sandbox.run_code(code)
        return execution.text

e2b_interpreter_tool = FunctionTool.from_defaults(
    name="execute_python",
    description="Execute python code in a Jupyter notebook cell and return result",
    fn=execute_python
)

# Initialize LLM
llm = OpenAI(model="gpt-4o")

# Initialize ReAct agent
agent = ReActAgent.from_tools([e2b_interpreter_tool], llm=llm, verbose=True)
agent.chat("Calculate how many r's are in the word 'strawberry'")
```
</CodeGroup>

