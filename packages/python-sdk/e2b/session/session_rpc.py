import asyncio
import json
import logging
from threading import Event
from typing import Any, Callable, Dict, Iterable, Iterator, List, Optional, Union

from e2b.session.exception import SessionException
from e2b.utils.future import DeferredFuture, run_async_func_in_new_loop
from jsonrpcclient import Ok, request_json
from jsonrpcclient.id_generators import decimal as decimal_id_generator
from jsonrpcclient.responses import Deserialized, Error, Response
from pydantic import BaseModel, PrivateAttr
from websockets import WebSocketClientProtocol, connect
from websockets.typing import Data

logger = logging.getLogger(__name__)


class RpcException(SessionException):
    def __init__(
        self,
        message: str,
        code: int,
        id: str,
        data: Optional[Dict] = None,
    ):
        super().__init__(message)
        self.data = data
        self.code = code
        self.message = message
        self.id = id


class Notification(BaseModel):
    """Nofification"""

    method: str
    params: Dict


Message = Response | Notification


def to_response_or_notification(response: Dict[str, Any]) -> Message:
    """Create a Response namedtuple from a dict"""
    logger.info(f"Received response: {response}")
    if "error" in response:
        return Error(
            response["error"]["code"],
            response["error"]["message"],
            response["error"].get("data"),
            response["id"],
        )
    elif "result" in response and "id" in response:
        return Ok(response["result"], response["id"])

    elif "params" in response:
        return Notification(method=response["method"], params=response["params"])

    raise ValueError("Invalid response", response)


def parse(deserialized: Deserialized) -> Union[Message, Iterable[Message]]:
    """Create a Response or list of Responses from a dict or list of dicts"""
    if isinstance(deserialized, str):
        raise TypeError("Use parse_json on strings")
    return (
        map(to_response_or_notification, deserialized)
        if isinstance(deserialized, list)
        else to_response_or_notification(deserialized)
    )


class SessionRpc(BaseModel):
    url: str
    on_message: Callable[[Notification], None]

    _id_generator: Iterator[int] = PrivateAttr(default_factory=decimal_id_generator)
    _waiting_for_replies: Dict[int, DeferredFuture] = PrivateAttr(default_factory=dict)
    _ws: Optional[WebSocketClientProtocol] = PrivateAttr()

    _process_cleanup: List[Callable[[], Any]] = PrivateAttr(default_factory=list)

    class Config:
        arbitrary_types_allowed = True

    async def connect(self):
        future_connect = DeferredFuture(self._process_cleanup)

        async def handle_messages():
            async for websocket in connect(
                self.url,
                ping_interval=None,
                ping_timeout=None,
                max_queue=None,
                max_size=None,
            ):
                self._ws = websocket
                cancel_event = Event()

                self._process_cleanup.append(cancel_event.set)

                async def keep_pong():
                    while not cancel_event.is_set():
                        await asyncio.sleep(5)
                        await websocket.pong()

                ponging = asyncio.to_thread(
                    run_async_func_in_new_loop,
                    keep_pong(),
                )

                ponging_task = asyncio.create_task(ponging)
                self._process_cleanup.append(ponging_task.cancel)

                logger.info(f"Connected to {self.url}")
                future_connect(None)
                try:
                    async for message in self._ws:
                        await self._receive_message(message)
                except Exception as e:
                    logger.error(f"Error: {e}")

            if not self._ws:
                raise Exception("Not connected")
            async for message in self._ws:
                await self._receive_message(message)

        handle_messages_task = asyncio.create_task(handle_messages())
        self._process_cleanup.append(handle_messages_task.cancel)
        await future_connect

    async def send_message(self, method: str, params: List[Any]) -> Any:
        if not self._ws:
            raise Exception("Not connected")

        id = next(self._id_generator)
        request = request_json(method, params, id)
        future_reply = DeferredFuture(self._process_cleanup)

        try:
            self._waiting_for_replies[id] = future_reply
            logger.info(f"Sending request: {request}")
            await self._ws.send(request)
            r = await future_reply
            logger.info(f"Received reply: {r}")
            return r
        except Exception as e:
            logger.error(f"Error: {request} {e}")
            raise e
        finally:
            del self._waiting_for_replies[id]
            logger.info(f"Removed waiting handler for {id}")

    async def _receive_message(self, data: Data):
        message = to_response_or_notification(json.loads(data))

        logger.info(f"Current waiting handlers: {self._waiting_for_replies}")
        if isinstance(message, Ok):
            if (
                message.id in self._waiting_for_replies
                and self._waiting_for_replies[message.id]
            ):
                self._waiting_for_replies[message.id](message.result)
                return
        elif isinstance(message, Error):
            if (
                message.id in self._waiting_for_replies
                and self._waiting_for_replies[message.id]
            ):
                self._waiting_for_replies[message.id].reject(
                    RpcException(
                        code=message.code,
                        message=message.message,
                        id=message.id,
                        data=message.data,
                    )
                )
                return

        elif isinstance(message, Notification):
            self.on_message(message)

    def _close(self):
        for cancel in self._process_cleanup:
            cancel()

        self._process_cleanup.clear()

        for handler in self._waiting_for_replies.values():
            handler.cancel()
            del handler

    async def close(self):
        self._close()

        if self._ws:
            await self._ws.close()
